{"ast":null,"code":"import { padStart, roundTo, hasRelative, formatOffset } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\"; // todo - remap caching\n\nlet intlLFCache = {};\n\nfunction getCachedLF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n\n  return dtf;\n}\n\nlet intlDTCache = {};\n\nfunction getCachedDTF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n\n  return dtf;\n}\n\nlet intlNumCache = {};\n\nfunction getCachedINF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n\n  return inf;\n}\n\nlet intlRelCache = {};\n\nfunction getCachedRTF(locString) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    base,\n    ...cacheKeyOpts\n  } = opts; // exclude `base` from the options\n\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n\n  return inf;\n}\n\nlet sysLocaleCache = null;\n\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const {\n      numberingSystem,\n      calendar\n    } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return loc.numberingSystem === \"latn\" || !loc.locale || loc.locale.startsWith(\"en\") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\";\n  }\n}\n/**\n * @private\n */\n\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n    const {\n      padTo,\n      floor,\n      ...otherOpts\n    } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = {\n        useGrouping: false,\n        ...opts\n      };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n\n}\n/**\n * @private\n */\n\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n    let z = undefined;\n\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({\n          minutes: dt.offset\n        });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({\n        minutes: dt.offset\n      });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts\n    };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts().map(_ref => {\n        let {\n          value\n        } = _ref;\n        return value;\n      }).join(\"\");\n    }\n\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n\n    if (this.originalZone) {\n      return parts.map(part => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName\n          });\n          return { ...part,\n            value: offsetName\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n\n}\n/**\n * @private\n */\n\n\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = {\n      style: \"long\",\n      ...opts\n    };\n\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n\n}\n/**\n * @private\n */\n\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n\n  static create(locale, numberingSystem, outputCalendar) {\n    let defaultToEN = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const specifiedLocale = locale || Settings.defaultLocale; // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n\n  static fromObject() {\n    let {\n      locale,\n      numberingSystem,\n      outputCalendar\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n    this.weekdaysCache = {\n      format: {},\n      standalone: {}\n    };\n    this.monthsCache = {\n      format: {},\n      standalone: {}\n    };\n    this.meridiemCache = null;\n    this.eraCache = {};\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === \"latn\") && (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);\n    }\n  }\n\n  redefaultToEN() {\n    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.clone({ ...alts,\n      defaultToEN: true\n    });\n  }\n\n  redefaultToSystem() {\n    let alts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.clone({ ...alts,\n      defaultToEN: false\n    });\n  }\n\n  months(length) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let defaultOK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? {\n        month: length,\n        day: \"numeric\"\n      } : {\n        month: length\n      },\n            formatStr = format ? \"format\" : \"standalone\";\n\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, \"month\"));\n      }\n\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length) {\n    let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let defaultOK = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format ? {\n        weekday: length,\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n      } : {\n        weekday: length\n      },\n            formatStr = format ? \"format\" : \"standalone\";\n\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, \"weekday\"));\n      }\n\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems() {\n    let defaultOK = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return listStuff(this, undefined, defaultOK, () => English.meridiems, () => {\n      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n      // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n      if (!this.meridiemCache) {\n        const intl = {\n          hour: \"numeric\",\n          hourCycle: \"h12\"\n        };\n        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, \"dayperiod\"));\n      }\n\n      return this.meridiemCache;\n    });\n  }\n\n  eras(length) {\n    let defaultOK = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = {\n        era: length\n      }; // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, \"era\"));\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n          results = df.formatToParts(),\n          matching = results.find(m => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt) {\n    let intlOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return this.locale === \"en\" || this.locale.toLowerCase() === \"en-us\" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\");\n  }\n\n  equals(other) {\n    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;\n  }\n\n}","map":{"version":3,"sources":["/Users/luna/Documents/Elice_1st_Project/portfolio-share-service-racer/front/node_modules/luxon/src/impl/locale.js"],"names":["padStart","roundTo","hasRelative","formatOffset","English","Settings","DateTime","IANAZone","intlLFCache","getCachedLF","locString","opts","key","JSON","stringify","dtf","Intl","ListFormat","intlDTCache","getCachedDTF","DateTimeFormat","intlNumCache","getCachedINF","inf","NumberFormat","intlRelCache","getCachedRTF","base","cacheKeyOpts","RelativeTimeFormat","sysLocaleCache","systemLocale","resolvedOptions","locale","parseLocaleString","localeStr","xIndex","indexOf","substring","uIndex","options","selectedStr","e","smaller","numberingSystem","calendar","intlConfigString","outputCalendar","includes","mapMonths","f","ms","i","dt","utc","push","mapWeekdays","listStuff","loc","length","defaultOK","englishFn","intlFn","mode","listingMode","supportsFastNumbers","startsWith","intl","PolyNumberFormatter","constructor","forceSimple","padTo","floor","otherOpts","Object","keys","intlOpts","useGrouping","minimumIntegerDigits","format","fixed","Math","PolyDateFormatter","originalZone","undefined","z","timeZone","zone","type","gmtOffset","offset","offsetZ","create","valid","setZone","plus","minutes","name","formatToParts","map","value","join","toJSDate","parts","part","offsetName","ts","timeZoneName","PolyRelFormatter","isEnglish","style","rtf","count","unit","formatRelativeTime","numeric","Locale","fromOpts","defaultToEN","specifiedLocale","defaultLocale","localeR","numberingSystemR","defaultNumberingSystem","outputCalendarR","defaultOutputCalendar","resetCache","fromObject","numbering","parsedLocale","parsedNumberingSystem","parsedOutputCalendar","weekdaysCache","standalone","monthsCache","meridiemCache","eraCache","fastNumbersCached","fastNumbers","isActuallyEn","hasNoWeirdness","clone","alts","getOwnPropertyNames","redefaultToEN","redefaultToSystem","months","month","day","formatStr","extract","weekdays","weekday","year","meridiems","hour","hourCycle","eras","era","field","df","dtFormatter","results","matching","find","m","toLowerCase","numberFormatter","relFormatter","listFormatter","equals","other"],"mappings":"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","sourcesContent":["import { padStart, roundTo, hasRelative, formatOffset } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n// todo - remap caching\n\nlet intlLFCache = {};\nfunction getCachedLF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlLFCache[key];\n  if (!dtf) {\n    dtf = new Intl.ListFormat(locString, opts);\n    intlLFCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlDTCache = {};\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlNumCache = {};\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n  return inf;\n}\n\nlet intlRelCache = {};\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  // private subtags and unicode subtags have ordering requirements,\n  // and we're not properly parsing this, so just strip out the\n  // private ones if they exist.\n  const xIndex = localeStr.indexOf(\"-x-\");\n  if (xIndex !== -1) {\n    localeStr = localeStr.substring(0, xIndex);\n  }\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    let selectedStr;\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n      selectedStr = localeStr;\n    } catch (e) {\n      const smaller = localeStr.substring(0, uIndex);\n      options = getCachedDTF(smaller).resolvedOptions();\n      selectedStr = smaller;\n    }\n\n    const { numberingSystem, calendar } = options;\n    return [selectedStr, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (outputCalendar || numberingSystem) {\n    if (!localeStr.includes(\"-u-\")) {\n      localeStr += \"-u\";\n    }\n\n    if (outputCalendar) {\n      localeStr += `-ca-${outputCalendar}`;\n    }\n\n    if (numberingSystem) {\n      localeStr += `-nu-${numberingSystem}`;\n    }\n    return localeStr;\n  } else {\n    return localeStr;\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\"\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    const { padTo, floor, ...otherOpts } = opts;\n\n    if (!forceSimple || Object.keys(otherOpts).length > 0) {\n      const intlOpts = { useGrouping: false, ...opts };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.originalZone = undefined;\n\n    let z = undefined;\n    if (this.opts.timeZone) {\n      // Don't apply any workarounds if a timeZone is explicitly provided in opts\n      this.dt = dt;\n    } else if (dt.zone.type === \"fixed\") {\n      // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.\n      // That is why fixed-offset TZ is set to that unless it is:\n      // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.\n      // 2. Unsupported by the browser:\n      //    - some do not support Etc/\n      //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata\n      const gmtOffset = -1 * (dt.offset / 60);\n      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;\n      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {\n        z = offsetZ;\n        this.dt = dt;\n      } else {\n        // Not all fixed-offset zones like Etc/+4:30 are present in tzdata so\n        // we manually apply the offset and substitute the zone as needed.\n        z = \"UTC\";\n        this.dt = dt.offset === 0 ? dt : dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n        this.originalZone = dt.zone;\n      }\n    } else if (dt.zone.type === \"system\") {\n      this.dt = dt;\n    } else if (dt.zone.type === \"iana\") {\n      this.dt = dt;\n      z = dt.zone.name;\n    } else {\n      // Custom zones can have any offset / offsetName so we just manually\n      // apply the offset and substitute the zone as needed.\n      z = \"UTC\";\n      this.dt = dt.setZone(\"UTC\").plus({ minutes: dt.offset });\n      this.originalZone = dt.zone;\n    }\n\n    const intlOpts = { ...this.opts };\n    intlOpts.timeZone = intlOpts.timeZone || z;\n    this.dtf = getCachedDTF(intl, intlOpts);\n  }\n\n  format() {\n    if (this.originalZone) {\n      // If we have to substitute in the actual zone name, we have to use\n      // formatToParts so that the timezone can be replaced.\n      return this.formatToParts()\n        .map(({ value }) => value)\n        .join(\"\");\n    }\n    return this.dtf.format(this.dt.toJSDate());\n  }\n\n  formatToParts() {\n    const parts = this.dtf.formatToParts(this.dt.toJSDate());\n    if (this.originalZone) {\n      return parts.map((part) => {\n        if (part.type === \"timeZoneName\") {\n          const offsetName = this.originalZone.offsetName(this.dt.ts, {\n            locale: this.dt.locale,\n            format: this.opts.timeZoneName,\n          });\n          return {\n            ...part,\n            value: offsetName,\n          };\n        } else {\n          return part;\n        }\n      });\n    }\n    return parts;\n  }\n\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = { style: \"long\", ...opts };\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\n/**\n * @private\n */\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n\n  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\n    const specifiedLocale = locale || Settings.defaultLocale;\n    // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n    const localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale());\n    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;\n    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode() {\n    const isActuallyEn = this.isEnglish();\n    const hasNoWeirdness =\n      (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n      (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n    return isActuallyEn && hasNoWeirdness ? \"en\" : \"intl\";\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: true });\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone({ ...alts, defaultToEN: false });\n  }\n\n  months(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems(defaultOK = true) {\n    return listStuff(\n      this,\n      undefined,\n      defaultOK,\n      () => English.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(\n            (dt) => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = { era: length };\n\n      // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find((m) => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  listFormatter(opts = {}) {\n    return getCachedLF(this.intl, opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")\n    );\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}