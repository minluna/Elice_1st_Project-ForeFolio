{"ast":null,"code":"import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nlet dtfCache = {};\n\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\"\n    });\n  }\n\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n        parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n        [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n\n  for (let i = 0; i < formatted.length; i++) {\n    const {\n      type,\n      value\n    } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\n\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n\n    return ianaZoneCache[name];\n  }\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n\n\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n\n\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n\n\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n\n    try {\n      new Intl.DateTimeFormat(\"en-US\", {\n        timeZone: zone\n      }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n\n    this.zoneName = name;\n    /** @private **/\n\n    this.valid = IANAZone.isValidZone(name);\n  }\n  /** @override **/\n\n\n  get type() {\n    return \"iana\";\n  }\n  /** @override **/\n\n\n  get name() {\n    return this.zoneName;\n  }\n  /** @override **/\n\n\n  get isUniversal() {\n    return false;\n  }\n  /** @override **/\n\n\n  offsetName(ts, _ref) {\n    let {\n      format,\n      locale\n    } = _ref;\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n  /** @override **/\n\n\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n  /** @override **/\n\n\n  offset(ts) {\n    const date = new Date(ts);\n    if (isNaN(date)) return NaN;\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    } // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n\n\n    const adjustedHour = hour === 24 ? 0 : hour;\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n  /** @override **/\n\n\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n  /** @override **/\n\n\n  get isValid() {\n    return this.valid;\n  }\n\n}","map":{"version":3,"sources":["/Users/luna/Documents/Elice_1st_Project/portfolio-share-service-racer/front/node_modules/luxon/src/zones/IANAZone.js"],"names":["formatOffset","parseZoneInfo","isUndefined","objToLocalTS","Zone","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","era","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","create","name","resetCache","isValidSpecifier","s","isValidZone","e","constructor","zoneName","valid","isUniversal","offsetName","ts","locale","offset","Date","isNaN","NaN","adOrBc","Math","abs","adjustedHour","asUTC","millisecond","asTS","over","equals","otherZone","isValid"],"mappings":"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","sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}